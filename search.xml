<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承、super、this、抽象类]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[继承概述由来多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可。如图所示：其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动 物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 访问父类中的非私有的属性和行为。好处 提高代码的复用性。 类与类之间产生了关系，是多态的前提。继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：123456class 父类 &#123; ... &#125; class 子类 extends 父类 &#123; ... &#125; 继承演示，代码如下： 1234567891011121314151617181920212223242526272829/* * 定义员工类Employee，做为父类 */class Employee &#123; String name; // 定义name属性 // 定义员工的工作方法 public void work() &#123; System.out.println("尽心尽力地工作"); &#125; &#125; /* * 定义讲师类Teacher 继承 员工类Employee */ class Teacher extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println("name=" + name); &#125; &#125; /* * 定义测试类 */ public class ExtendDemo01 &#123; public static void main(String[] args) &#123; // 创建一个讲师类对象 Teacher t = new Teacher(); // 为该员工类的name属性进行赋值 t.name = "小明"; // 调用该员工的printName()方法 t.printName(); // name = 小明 // 调用Teacher类继承来的work()方法 t.work(); // 尽心尽力地工作 &#125; &#125; 继承后的特点——成员变量当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？ 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下： 12345678910111213141516171819202122class Fu &#123; // Fu中的成员变量。 int num = 5; &#125;class Zi extends Fu &#123; // Zi中的成员变量 int num2 = 6; // Zi中的成员方法 public void show() &#123; // 访问父类中的num， System.out.println("Fu num="+num); // 继承而来，所以直接访问。 // 访问子类中的num2 System.out.println("Zi num2="+num2); &#125; &#125;class ExtendDemo02 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125; &#125; 演示结果： Fu num = 5 Zi num2 = 6 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940 // Zi中的成员变量 int num2 = 6; // Zi中的成员方法 public void show() &#123; // 访问父类中的num， System.out.println("Fu num="+num); // 继承而来，所以直接访问。 // 访问子类中的num2 System.out.println("Zi num2="+num2); &#125; &#125;class ExtendDemo02 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125; &#125; 演示结果： Fu num = 5 Zi num2 = 6class Fu &#123; // Fu中的成员变量。 int num = 5; &#125;class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; // 访问父类中的num System.out.println("Fu num=" + num); // 访问子类中的num System.out.println("Zi num=" + num); &#125; &#125; class ExtendsDemo03 &#123; public static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125; &#125;演示结果： Fu num = 6 Zi num = 6 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰 父类成员变量，类似于之前学过的 this 。使用格式： 1super.父类成员变量名 子类方法需要修改，代码如下 1234567891011class Zi extends Fu &#123; // Zi中的成员变量 int num = 6; public void show() &#123; //访问父类中的num System.out.println("Fu num=" + super.num); //访问子类中的num System.out.println("Zi num=" + this.num); &#125; &#125;演示结果： Fu num = 5 Zi num = 6 Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能 直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员 变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。 继承后的特点——成员方法当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？ 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对 应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下： 123456789101112131415161718class Fu&#123; public void show()&#123; System.out.println("Fu类中的show方法执行"); &#125; &#125;class Zi extends Fu&#123; public void show2()&#123; System.out.println("Zi类中的show2方法执行"); &#125; &#125;public class ExtendsDemo04&#123; public static void main(String[] args) &#123; Zi z = new Zi(); //子类中没有show方法，但是可以找到父类方法去执行 z.show(); z.show2(); &#125; &#125; 成员方法重名——重写(Override)如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效 果，也称为重写或者复写。声明不变，重新实现。代码如下：123456789101112131415161718class Fu &#123; public void show() &#123; System.out.println("Fu show"); &#125; &#125;class Zi extends Fu &#123; //子类重写了父类的show方法 public void show() &#123; System.out.println("Zi show"); &#125; &#125;public class ExtendsDemo05&#123; public static void main(String[] args) &#123; Zi z = new Zi(); // 子类中有show方法，只执行重写后的show方法 z.show(); // Zi show &#125; &#125; 重写的应用子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从 而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下： 1234567891011121314151617181920212223242526272829303132class Phone &#123; public void sendMessage()&#123; System.out.println("发短信"); &#125; public void call()&#123; System.out.println("打电话"); &#125; public void showNum()&#123; System.out.println("来电显示号码"); &#125; &#125;//智能手机类class NewPhone extends Phone &#123; //重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum()&#123; //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像"); &#125; &#125; public class ExtendsDemo06 &#123; public static void main(String[] args) &#123; // 创建子类对象 NewPhone np = new NewPhone()； // 调用父类继承而来的方法 np.call(); // 调用子类重写的方法 np.showNum(); &#125; &#125; 这里重写时，用到super.父类成员方法，表示调用父类的成员方法。 注意事项 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。继承后的特点——构造方法当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？首先我们要回忆两个事情，构造方法的定义格式和作用。 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构 造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代 码如下：12345678910111213141516171819class Fu &#123; private int n; Fu()&#123; System.out.println("Fu()"); &#125;&#125;class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 super(); System.out.println("Zi（）"); &#125; &#125;public class ExtendsDemo07&#123; public static void main (String args[])&#123; Zi zi = new Zi(); &#125;&#125;输出结果： Fu（） Zi（） super和this父类空间优先于子类对象产生在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空 间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构 造方法调用时，一定先调用父类的构造方法。 super和this的含义 super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。super和this的用法 访问成员1234this.成员变量 ‐‐ 本类的 super.成员变量 ‐‐ 父类的 this.成员方法名() ‐‐ 本类的 super.成员方法名() ‐‐ 父类的 用法演示，代码如下： 1234567891011121314151617181920212223class Animal &#123; public void eat() &#123; System.out.println("animal : eat"); &#125;&#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println("cat : eat"); &#125; public void eatTest() &#123; this.eat(); // this 调用本类的方法 super.eat(); // super 调用父类的方法 &#125;&#125; public class ExtendsDemo08 &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Cat c = new Cat(); c.eatTest(); &#125;&#125; 输出结果为： animal : eat cat : eat animal : eat 访问构造方法12this(...) ‐‐ 本类的构造方法 super(...) ‐‐ 父类的构造方法 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 继承的特点 Java只支持单继承，不支持多继承。 123//一个类只能有一个父类，不可以有多个父类。class C extends A&#123;&#125; //ok class C extends A，B... //error Java支持多层继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。 子类和父类是一种相对的概念 抽象类概述由来父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法 的类就是抽象类。 定义 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。abstract使用格式抽象方法使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。定义格式：1修饰符 abstract 返回值类型 方法名 (参数列表)； 代码举例： 1public abstract void run()； 抽象类如果一个类包含抽象方法，那么该类必须是抽象类。定义格式： 12abstract class 类名字 &#123; &#125; 代码举例： 123public abstract class Animal &#123; public abstract void run()；&#125; 抽象的使用继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父 类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。代码举例： 1234567891011121314public class Cat extends Animal &#123; public void run ()&#123; System.out.println("小猫在墙头走~~~")； &#125;&#125; public class CatTest &#123; public static void main(String[] args) &#123; // 创建子类对象 Cat c = new Cat(); // 调用run方法 c.run(); &#125; &#125;输出结果： 小猫在墙头走~~~ 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 注意事项关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设 计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象 类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有 意义。]]></content>
      <categories>
        <category>java基础</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>继承</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类、static关键字、Arrays类、Math类]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%B8%B8%E7%94%A8API%2FString%E7%B1%BB%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[String类String类概述概述java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实 例。类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻 译为大写或小写的所有字符的字符串的副本。 特点 字符串不变：字符串的值在创建后不能被更改。 1234String s1 = "abc";s1 += "d";System.out.println(s1); // "abcd" // 内存中有"abc"，"abcd"两个对象，s1从指向"abc"，改变指向，指向了"abcd"。 因为String对象是不可变的，所以它们可以被共享。 123String s1 = "abc";String s2 = "abc";// 内存中只有一个"abc"对象被创建，同时被s1和s2共享。 “abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。 123456例如： String str = "abc"; 相当于： char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data);// String底层是靠字符数组实现的。 使用步骤 查看类 java.lang.String ：此类不需要导入。 查看构造方法 public String() ：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。 构造举例，代码如下：123456// 无参构造String str = new String（）； // 通过字符数组构造 char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars); // 通过字节数组构造 byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes); 常用方法判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小 写。方法演示，代码如下：12345678910public class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = "hello"; String s2 = "hello"; String s3 = "HELLO"; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // false System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。 获取功能的方法 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符 串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到 endIndex截取字符串。含beginIndex，不含endIndex。方法演示，代码如下：123456789101112131415161718192021222324252627public class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "helloworld"; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println("‐‐‐‐‐‐‐‐"); // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s = "helloworld"; String s2 = s.concat("**hello java"); System.out.println(s2);// helloworld**hello java // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println("‐‐‐‐‐‐‐‐"); // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf("l")); System.out.println(s.indexOf("owo")); System.out.println(s.indexOf("ak")); System.out.println("‐‐‐‐‐‐‐‐"); // String substring(int start):从start开始截取字符串到字符串结尾 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println("‐‐‐‐‐‐‐‐"); // String substring(int start,int end):从start到end截取字符串。含start，不含end。 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125; &#125; 转换功能的方法 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 * public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使 用replacement字符串替换。方法演示，代码如下1234567891011121314151617181920public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "abcde"; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) &#123; System.out.println(bytes[x]); &#125; System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); // 替换字母it为大写IT String str = "itdd it"; String replace = str.replace("it", "IT"); System.out.println(replace); System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); &#125; &#125; CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中. 分割功能的方法 public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。方法演示，代码如下：12345678910public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "aa|bb|cc"; String[] strArray = s.split("|"); // ["aa","bb","cc"] for(int x = 0; x &lt; strArray.length; x++) &#123; System.out.println(strArray[x]); // aa bb cc &#125; &#125;&#125; static关键字概述关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 定义和使用格式 类变量当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。定义格式：1static 数据类型 变量名； 举例： 1static int numberID； 比如说，基础班新班开班，学员报到。现在想为每一位新来报到的同学编学号（sid），从第一名同学开始，sid为 1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学 号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关。所以，我们可以这样定义一个静态变量numberOfStudent，代码如下： 1234567891011121314151617181920212223242526272829public class Student &#123; private String name; private int age; // 学生的id private int sid; // 类变量，记录学生数量，分配学号 public static int numberOfStudent = 0; public Student(String name, int age)&#123; this.name = name; this.age = age; // 通过 numberOfStudent 给学生分配学号 this.sid = ++numberOfStudent; &#125; // 打印属性值 public void show() &#123; System.out.println("Student : name=" + name + ", age=" + age + ", sid=" + sid ); &#125;&#125;public class StuDemo &#123; public static void main(String[] args) &#123; Student s1 = new Student("张三", 23); Student s2 = new Student("李四", 24); Student s3 = new Student("王五", 25); Student s4 = new Student("赵六", 26); s1.show(); // Student : name=张三, age=23, sid=1 s2.show(); // Student : name=李四, age=24, sid=2 s3.show(); // Student : name=王五, age=25, sid=3 s4.show(); // Student : name=赵六, age=26, sid=4 &#125;&#125; 静态方法当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要 创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。定义格式：123修饰符 static 返回值类型 方法名 (参数列表)&#123; // 执行语句 &#125; 举例：在Student类中定义静态方法 123public static void showNum() &#123; System.out.println("num:" + numberOfStudent);&#125; 静态方法调用的注意事项： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 静态方法只能访问静态成员调用格式被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属 于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。格式：1234// 访问类变量类名.类变量名； // 调用静态方法类名.静态方法名(参数)； 调用演示，代码如下： 12345678public class StuDemo2 &#123; public static void main(String[] args) &#123; // 访问类变量 System.out.println(Student.numberOfStudent); // 调用静态方法 Student.showNum(); &#125;&#125; 静态原理图解static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 ## 静态代码块 静态代码块：定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。格式：12345public class ClassName&#123; static &#123; // 执行语句 &#125;&#125; 作用：给类变量进行初始化赋值。用法演示，代码如下： 1234567891011public class Game &#123; public static int number; public static ArrayList&lt;String&gt; list; static &#123; // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add("张三"); list.add("李四"); &#125;&#125; static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。 Arrays类概述java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来 非常简单。 操作数组的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 123456789public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9] &#125; public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 1234567public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;; System.out.println("排序前:"+ Arrays.toString(arr)); // 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2] // 升序排序 Arrays.sort(arr); System.out.println("排序后:"+ Arrays.toString(arr));// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46, 48] &#125; Math类概述java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具 类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 基本运算的方法 public static double abs(double a) ：返回 double 值的绝对值 12double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的小的整数。 123double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(‐3.3); //d2的值为 ‐3.0double d3 = Math.ceil(5.1); //d3的值为 6.0 public static double floor(double a) ：返回小于等于参数大的整数。 123double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(‐3.3); //d2的值为‐4.0double d3 = Math.floor(5.1); //d3的值为 5.0 public static long round(double a) ：返回接近参数的 long。(相当于四舍五入方法) 12long d1 = Math.round(5.5); //d1的值为6.0long d2 = Math.round(5.4); //d2的值为5.0]]></content>
      <categories>
        <category>java基础</category>
        <category>常用API</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
        <tag>static</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用API之Scanner、Random、ArrayList类]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%B8%B8%E7%94%A8API%2F%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner%E3%80%81Random%E3%80%81ArrayList%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Scanner类什么是Scanner类一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt() System.in 系统输入指的是通过键盘录入数据. 引用类型使用步骤导包使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 格 式： 1import 包名.类名; 举例： 1java.util.Scanner; 创建对象使用该类的构造方法，创建一个该类的对象。 格式： 1数据类型 变量名 = new 数据类型（参数列表） 举例： 1Scanner sc = new Scanner(System.in); 调用方法调用该类的成员方法，完成指定功能。 格式： 1变量名.方法名 举例： 1int i = sc.nextInt(); // 接收一个键盘录入的整数 Scanner使用步骤查看类 java.util.Scanner ：该类需要import导入后使用。查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。查看成员方法 public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。 使用Scanner类，完成接收键盘录入数据的操作，代码如下：12345678910111213//1. 导包 import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println("请录入一个整数："); int i = sc.nextInt(); //4. 输出数据 System.out.println("i:"+i); &#125; &#125; 匿名对象概念创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用 场景非常有限。 匿名对象 ：没有变量名的对象。格式：1new 类名(参数列表)； 举例： 1new Scanner(System.in)； 应用场景 创建匿名对象直接调用方法，没有变量名。 1new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，造成浪费，请看如下代码。 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 一个匿名对象，只能使用一次。 匿名对象可以作为方法的参数和返回值 作为参数： 12345678910 public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125; 作为返回值1234567891011 public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in);&#125; Random类什么是Random类此类的实例用于生成伪随机数。例如，以下代码使用户能够得到一个随机数： 12Random r = new Random();int i = r.nextInt(); Random使用步骤查看类 java.util.Random ：该类需要 import导入使后使用。查看构造方法 public Random() ：创建一个新的随机数生成器。查看成员方法 public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 int 值。使用Random类，完成生成3个10以内的随机整数的操作，代码如下：123456789101112//1. 导包 import java.util.Random;public class Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println("number:"+ number); &#125; &#125; 创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。 ArrayList类引入——对象数组使用学生数组，存储三个学生对象，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast.day07.demo05;public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;public class StudentArray &#123; public static void main(String[] args) &#123; //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student("曹操",40); Student s2 = new Student("刘备",35); Student s3 = new Student("孙权",30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int x=0; x&lt;students.length; x++) &#123; Student s = students[x]; System.out.println(s.getName()+"‐‐‐"+s.getAge()); &#125; &#125;&#125; 到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据。 什么是ArrayList类java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可不断添加元素，其大小也自动增长。 ArrayList使用步骤查看类 java.util.ArrayList ：该类需要 import导入使后使用。 ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使 用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：1ArrayList&lt;String&gt; ,ArrayList&lt;Student&gt; 查看构造方法 public ArrayList() ：构造一个内容为空的集合。基本格式:1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 查看成员方法 public boolean add(E e) ： 将指定的元素添加到此集合的尾部。 参数 E e ，在构造ArrayList对象时， 指定了什么数据类型，那么 add(E e) 方法中，只能添加什么数据 类型的对象。使用ArrayList类，存储三个字符串元素，代码如下:123456789101112131415161718public class Test02StudentArrayList &#123; public static void main(String[] args) &#123; //创建学生数组 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //创建学生对象 String s1 = "曹操"; String s2 = "刘备"; String s3 = "孙权"; //打印学生ArrayList集合 System.out.println(list); //把学生对象作为元素添加到集合 list.add(s1); list.add(s2); list.add(s3); //打印学生ArrayList集合 System.out.println(list); &#125;&#125; 常用方法和遍历对于元素的操作,基本体现在——增、删、查。常用的方法有： public boolean add(E e) ：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index) ：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。这些都是基本的方法，操作非常简单，代码如下:12345678910111213141516171819202122public class ArrayListMethod &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //public E get(int index):返回指定索引处的元素 System.out.println("get:"+list.get(0)); System.out.println("get:"+list.get(1)); System.out.println("get:"+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println("size:"+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println("remove:"+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; 如何存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 不能写，但是存储基本数据类型对应的 包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下：|基本类型 | 基本类型包装类||byte |Byte ||short |Short ||int |Integer ||long |Long ||ﬂoat |Float ||double |Double ||char |Character||boolean |Boolean |我们发现，只有 Integer 和 Character 需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数 据，代码如下： 12345678public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); System.out.println(list); &#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>常用API</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Random</tag>
        <tag>Scanner</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象和封装]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[面向对象思想概述概述Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下， 使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面 向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算 机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去 操作实现。 举例洗衣服: 面向过程：把衣服脱下来–&gt;找一个盆–&gt;放点洗衣粉–&gt;加点水–&gt;浸泡10分钟–&gt;揉一揉–&gt;清洗衣服–&gt;拧干–&gt;晾 起来 面向对象：把衣服脱下来–&gt;打开全自动洗衣机–&gt;扔衣服–&gt;按钮–&gt;晾起来区别: 面向过程：强调步骤。 面向对象：强调对象，这里的对象就是洗衣机。特点面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。 面向对象的语言中，包含了三大基本特征，即封装、继承和多态。类和对象环顾周围，你会发现很多对象，比如桌子，椅子，同学，老师等。桌椅属于办公用品，师生都是人类。那么什么是 类呢？什么是对象呢？什么是类 类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该 类事物。 现实中，描述一类事物： 属性：就是该事物的状态信息。 行为：就是该事物能够做什么。 举例：小猫。 属性：名字、体重、年龄、颜色。 行为：走、跑、叫。什么是对象 对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性 和行为。现实中，一类事物的一个实例：一只小猫。举例：一只小猫。 属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。 类与对象的关系类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 类的定义事物与类的对比现实世界的一类事物：属性：事物的状态信息。 行为：事物能够做什么。Java中用class描述事物也是如此：成员变量：对应事物的属性 成员方法：对应事物的行为 类的定义格式1234public class ClassName &#123; //成员变量 //成员方法 &#125; 定义类：就是定义类的成员，包括成员变量和成员方法。 成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法：和以前定义方法几乎是一样的。类的定义格式举例：1234567891011121314public class Student &#123; //成员变量 String name；//姓名 int age；//年龄 //成员方法 //学习的方法 publicvoid study() &#123; System.out.println("好好学习，天天向上"); &#125; //吃饭的方法 public void eat() &#123; System.out.println("学习饿了要吃饭"); &#125;&#125; 对象的使用对象的使用格式创建对象： 1类名 对象名 = new 类名(); 使用对象访问类中的成员: 12对象名.成员变量；对象名.成员方法()； 对象的使用格式举例: 12345678910111213141516171819public static void main(String[] args) &#123; //创建对象格式：类名 对象名 = new 类名(); Student s = new Student(); System.out.println("s:"+s); //Student@100363 //直接输出成员变量值 System.out.println("姓名："+s.name); //null System.out.println("年龄："+s.age); //0 System.out.println("‐‐‐‐‐‐‐‐‐‐"); //给成员变量赋值 s.name = "赵丽颖"; s.age = 18; //再次输出成员变量的值 System.out.println("姓名："+s.name); //赵丽颖 System.out.println("年龄："+s.age); //18 System.out.println("‐‐‐‐‐‐‐‐‐‐"); //调用成员方法 s.study(); // "好好学习，天天向上" s.eat(); // "学习饿了要吃饭" &#125; 成员变量的默认值与数组定义后默认值一样 对象内存图一个对象，调用一个方法内存图 >通过上图，我们可以理解，在栈内存中运行的方法，遵循"先进后出，后进先出"的原则。变量p指向堆内存中 的空间，寻找方法信息，去执行该方法。 >但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存 了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。 ### 两个对象，调用同一方法内存图 >对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息 只保存一份，节约内存空间。 ## 一个引用，作为参数传递到方法中内存图 引用类型作为参数，传递的是地址值。 ## 成员变量和局部变量区别 变量根据定义位置的不同，我们给变量起了不同的名字。如下图所示： * 在类中的位置不同 重点 * 成员变量：类中，方法外 * 局部变量：方法中或者方法声明上(形式参数) * 作用范围不一样 重点 * 成员变量：类中 * 局部变量：方法中 * 初始化值的不同 重点 * 成员变量：有默认值 * 局部变量：没有默认值。必须先定义，赋值，最后使用 * 在内存中的位置不同 了解 * 成员变量：堆内存 * 局部变量：栈内存 * 生命周期不同 了解 * 成员变量：随着对象的创建而存在，随着对象的消失而消失 * 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。 # 封装 ## 封装概述 ### 概述 面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的 方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 ### 原则 将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 ## 封装的步骤 1. 使用 private 关键字来修饰成员变量。 2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。 ## 封装的操作——private关键字 ### private的含义 1. private是一个权限修饰符，代表最小权限。 2. 可以修饰成员变量和成员方法。 3. 被private修饰后的成员变量和成员方法，只在本类中才能访问。 ### private的使用格式 1private 数据类型 变量名; 使用 private 修饰成员变量，代码如下: 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下： 12345678910111213141516public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125;&#125; 封装优化1——this关键字我们发现 setXxx 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意 了呢？代码如下： 12345678910public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125;&#125; 经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 setXxx() 的形参变量名后，方 法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无 法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题。 this的含义this代表所在类的当前对象的引用（地址值），即对象自己的引用。 记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 this使用格式123456789101112131415161718192021this.成员变量名```java使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下：public class Student &#123; private String name; private int age; public void setName(String name) &#123; //name = name; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; //age = age; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 小贴士：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写 封装优化2——构造方法当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法， 一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。 构造方法的定义格式123修饰符 构造方法名(参数列表)&#123; // 方法体 &#125; 123456789101112构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用 构造方法后，代码如下：public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 注意事项 如果你不提供构造方法，系统会给出无参数构造方法。 如果你提供了构造方法，系统将不再提供无参数构造方法。 构造方法是可以重载的，既可以定义参数，也可以不定义参数。标准代码——JavaBeanJavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无 参数的构造方法，提供用来操作成员变量的 set 和 get 方法.12345678public class ClassName&#123; //成员变量 //构造方法 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 //getXxx() //setXxx() &#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>封装</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式七大原则之接口隔离原则]]></title>
    <url>%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[基本介绍1) 客户端不应该依赖它不需要的接 口，即一个类对另一个类的依赖 应该建立在最小的接口上2) 先看一张图:3) 类A通过接口Interface1依赖类B，类C通过 接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口， 那么类B和类D必须去实现他们不需要的方 法。4) 按隔离原则应当这样处理： 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖 关系。也就是采用接口隔离原则 应用实例1) 类A通过接口Interface1依赖类B， 类C通过接口Interface1依赖类D， 请编写代码完成此应用实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package principle.segregation;public class Segregation1 &#123; public static void main(String[] args) &#123; &#125;&#125;//接口interface Interface1&#123; void operation1(); void operation2(); void operation3(); void operation4(); void operation5();&#125;class B implements Interface1&#123; @Override public void operation1() &#123; System.out.println("B 实现了 operation1"); &#125; @Override public void operation2() &#123; System.out.println("B 实现了 operation2"); &#125; @Override public void operation3() &#123; System.out.println("B 实现了 operation3"); &#125; @Override public void operation4() &#123; System.out.println("B 实现了 operation4"); &#125; @Override public void operation5() &#123; System.out.println("B 实现了 operation5"); &#125;&#125;class D implements Interface1&#123; @Override public void operation1() &#123; System.out.println("D 实现了 operation1"); &#125; @Override public void operation2() &#123; System.out.println("D 实现了 operation2"); &#125; @Override public void operation3() &#123; System.out.println("D 实现了 operation3"); &#125; @Override public void operation4() &#123; System.out.println("D 实现了 operation4"); &#125; @Override public void operation5() &#123; System.out.println("D 实现了 operation5"); &#125;&#125;class A&#123;//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法 public void depend1(Interface1 i)&#123; i.operation1(); &#125; public void depend2(Interface1 i)&#123; i.operation1(); &#125; public void depend3(Interface1 i)&#123; i.operation1(); &#125;&#125;class C&#123;//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法 public void depend1(Interface1 i)&#123; i.operation1(); &#125; public void depend4(Interface1 i)&#123; i.operation4(); &#125; public void depend5(Interface1 i)&#123; i.operation5(); &#125;&#125; 应传统方法的问题和使用接口隔离原则改进1) 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不 需要的方法2) 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则3) 接口Interface1中出现的方法，根据实际情况拆分为三个接口4) 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package principle.segregation.improve;public class Segregation1 &#123; public static void main(String[] args) &#123; &#125;&#125;// 接口1interface Interface1 &#123; void operation1();&#125;// 接口2interface Interface2 &#123; void operation2(); void operation3();&#125;// 接口3interface Interface3 &#123; void operation4(); void operation5();&#125;class B implements Interface1, Interface2 &#123; @Override public void operation1() &#123; System.out.println("B 实现了 operation1"); &#125; @Override public void operation2() &#123; System.out.println("B 实现了 operation2"); &#125; @Override public void operation3() &#123; System.out.println("B 实现了 operation3"); &#125;&#125;class D implements Interface1, Interface3 &#123; @Override public void operation1() &#123; &#125; @Override public void operation4() &#123; System.out.println("D 实现了 operation4"); &#125; @Override public void operation5() &#123; System.out.println("D 实现了 operation5"); &#125;&#125;class A &#123;// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法 public void depend1(Interface1 i) &#123; i.operation1(); &#125; public void depend2(Interface2 i) &#123; i.operation2(); &#125; public void depend3(Interface2 i) &#123; i.operation3(); &#125;&#125;class C &#123;// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法 public void depend1(Interface1 i) &#123; i.operation1(); &#125; public void depend4(Interface3 i) &#123; i.operation4(); &#125; public void depend5(Interface3 i) &#123; i.operation5(); &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
        <category>七大设计原则</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>七大原则</tag>
        <tag>接口隔离原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[git 安装只需安装包一直点next就行，安装成功只需右键桌面 如有下图的东西就说明安装成功打开git bash 输入git –version 出现下图效果就成功下面配置你的个人信息（全局） 12$ git config --global user.name &quot;Ldp&quot;$ git config --global user.email &quot;690150057@qq.com&quot; 然后跳转到你想作为仓库的文件夹（cd /d/mygit） 1$ git init 这时你的文件夹就会生成一个.git文件夹，这个文件夹是隐藏的，你可以自己通过系统设置看到你可以通过下面命令配置该仓库作者信息 1$ git config user.name &quot;Ldp&quot; 克隆项目当前文件夹（文件夹不要是仓库） 1$ git clone 地址 下面命令是在当前文件夹创建文件 、将文件添加到git仓库中转站和提交到git仓库 12345$ touch a.java //创建a.java文件$ add a.java //将a.java 文件添加到中转站$ add . //将本文件夹所有文件添加到中转站$ git status //查看状态$ git commit -m &apos;提交信息&apos; //中转站文件提交 可以新建忽略文件.gitignore里面就可以添加被忽略的文件！文件名 表示除了该文件/文件夹名 该文件夹也被忽略/文件夹名/**/文件名 忽略该文件夹及其子文件夹 下面命令移除文件 12$ git rm 文件名$ git rm --cached 文件名 文件改名 1git mv 文件名 文件名 日志显示 1234567$ git log$ git log -p$ git log -p -1$ git log --oneline$ git log --oneline -p$ git log --name-only$ git log --name-status]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组概念 数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的定义方式一 格式： 1数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度]; 数组定义格式详解： 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [] : 表示数组。 数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 new：关键字，创建数组使用的关键字。 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [长度]：数组的长度，表示数组容器中可以存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改。 和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。 举例：定义可以存储3个整数的数组容器，代码如下： 1int[] arr = new int[3]; 方式二 格式： 1数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[]&#123;元素1,元素2,...&#125;; 举例：定义存储1，2，3，4，5整数的数组容器 1int[] arr = new int[]&#123;1,2,3,4,5&#125;; 方式三 格式： 1数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;; 举例：定义存储1，2，3，4，5整数的数组容器 1int[] arr = &#123;1,2,3,4,5&#125;; 数组的访问 索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。 格式： 1数组名[索引] 数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： 数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数 组的最大索引值为 数组名.length-1 。 1234public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4,5&#125;; //打印数组的属性，输出结果是5 System.out.println(arr.length); &#125; 索引访问数组中的元素： 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素1234567891011public static void main(String[] args) &#123; //定义存储int类型数组，赋值元素1，2，3，4，5 int[] arr = &#123;1,2,3,4,5&#125;; //为0索引元素赋值为6 arr[0] = 6; //获取数组0索引上的元素 int i = arr[0]; System.out.println(i); //直接输出数组0索引元素 System.out.println(arr[0]);&#125; 数组原理内存图内存概述内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 Java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 JVM的内存划分： 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 ## 数组在内存中的存储 * 一个数组内存图 1234public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr);//[I@5f150435 &#125; 以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆 内存中存储的，而方法中的变量arr保存的是数组的地址。 输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素 两个数组内存图12345 public static void main(String[] args) &#123; int[] arr = new int[3]; int[] arr2 = new int[2]; System.out.println(arr); System.out.println(arr2); &#125; ## 两个变量指向一个数组 12345678910111213141516 观察一下代码，运行后会出现什么结果。public static void main(String[] args) &#123; // 定义数组，存储3个元素 int[] arr = new int[3]; //数组索引进行赋值 arr[0] = 5; arr[1] = 6; arr[2] = 7; //输出3个索引上的元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); //定义数组变量arr2，将arr的地址赋值给arr2 int[] arr2 = arr; arr2[1] = 9; System.out.println(arr[1]); &#125; 数组的常见操作数组越界异常观察一下代码，运行后会出现什么结果。 1234public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);&#125; 创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运 行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一 旦出现了，就必须要修改我们编写的代码 数组空指针异常观察一下代码，运行后会出现什么结果。 12345public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; arr = null; System.out.println(arr[0]);｝ arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候 会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修 改我们编写的代码。空指针异常在内存图中的表现 数组遍历【重点】 数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。123456public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 数组获取最大值元素 最大值获取：从数组的所有元素中找出最大值。 实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println("数组最大值是： " + max);&#125; 数组反转 数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思想：数组最远端的元素互换位置。 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 123456789101112public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式七大原则之单一职责原则]]></title>
    <url>%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[单一职责原则基本介绍对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2 应用实例 方案一 12345678910111213141516package principle.singleresponsibility;public class SingleResponsibility1 &#123; public static void main(String[] args) &#123; Vehicle vehicle = new Vehicle(); vehicle.run("汽车"); vehicle.run("轮船"); vehicle.run("飞机"); &#125;&#125;// 交通工具类class Vehicle&#123; public void run(String vehicle)&#123; System.out.println(vehicle + "在公路上跑"); &#125;&#125; 方案一分析 在run方法中，违反了单一职责原则 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可 方案二 12345678910111213141516171819202122232425262728package principle.singleresponsibility;public class SingleResponsibility2 &#123; public static void main(String[] args) &#123; RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run("汽车"); WaterVehicle waterVehicle = new WaterVehicle(); waterVehicle.run("轮船"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run("飞机"); &#125;&#125;class RoadVehicle&#123; public void run(String vehicle)&#123; System.out.println(vehicle + "在公路上跑"); &#125;&#125;class WaterVehicle&#123; public void run(String vehicle)&#123; System.out.println(vehicle + "在水上跑"); &#125;&#125;class AirVehicle&#123; public void run(String vehicle)&#123; System.out.println(vehicle + "在空中跑"); &#125;&#125; 方案2的分析 遵守单一职责原则 但是这样做的改动很大，即将类分解，同时修改客户端 改进：直接修改Vehicle 类，改动的代码会比较少=&gt;方案3 方案三 12345678910111213141516171819202122package principle.singleresponsibility;public class SingleResponsibility3 &#123; public static void main(String[] args) &#123; Vehicle1 vehicle = new Vehicle1(); vehicle.runOnRoad("汽车"); vehicle.runOnWater("轮船"); vehicle.runOnAir("飞机"); &#125;&#125;class Vehicle1 &#123; public void runOnRoad(String vehicle) &#123; System.out.println(vehicle + "在公路上跑"); &#125; public void runOnWater(String vehicle) &#123; System.out.println(vehicle + "在水上跑"); &#125; public void runOnAir(String vehicle) &#123; System.out.println(vehicle + "在空中跑"); &#125;&#125; 方式3的分析 这种修改方法没有对原来的类做大的修改，只是增加方法 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责单一职责原则注意事项和细节1) 降低类的复杂度，一个类只负责一项职责。2) 提高类的可读性，可维护性3) 降低变更引起的风险4) 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则]]></content>
      <categories>
        <category>java设计模式</category>
        <category>七大设计原则</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>七大原则</tag>
        <tag>单一职责原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程控制之选择语句和循环语句]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[选择语句选择语句–switch switch语句格式： 1234567891011switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break; &#125; 执行流程 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; //定义变量，判断是星期几 int weekday = 6; //switch语句实现选择 switch(weekday) &#123; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.out.println("星期五"); break; case 6: System.out.println("星期六"); break; case 7: System.out.println("星期日"); break; default: System.out.println("你输入的数字有误"); break; &#125; &#125; case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运 行，直到遇到break，或者整体switch结束。 1234567891011121314public static void main(String[] args) &#123; int i = 5; switch (i)&#123; case 0: System.out.println("执行case0"); break; case 5: System.out.println("执行case5"); case 10: System.out.println("执行case10"); default: System.out.println("执行default"); &#125;&#125; 上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接 运行完整体switch。由于case存在穿透性，因此初学者在编写switch语句时，必须要写上break。 循环语句循环概述循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 循环语句1–for for循环语句格式： 123for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③ &#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化 ②负责判断是否满足循环条件，不满足则跳出循环 ③具体执行的语句 ④循环后，循环条件所涉及变量的变化情况 123456789101112131415161718192021 for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③ &#125;public static void main(String[] args) &#123; //控制台输出10次HelloWorld，不使用循环 System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"); //用循环改进，循环10次 //定义变量从0开始，循环条件为&lt;10 for(int x = 0; x &lt; 10; x++) &#123; System.out.println("HelloWorld"+x); &#125;&#125; 循环语句2–while while循环语句格式: 12345初始化表达式① while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; 执行流程 执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化。 ②负责判断是否满足循环条件，不满足则跳出循环。 ③具体执行的语句。 ④循环后，循环变量的变化情况。 while循环输出10次HelloWorld 1234567891011public static void main(String[] args) &#123; //while循环实现打印10次HelloWorld //定义初始化变量 int i = 1; //循环条件&lt;=10 while(i&lt;=10)&#123; System.out.println("HelloWorld"); //步进 i++; &#125;&#125; 循环语句3–do…while do…while循环格式 12345初始化表达式① do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 执行流程 执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。 ①负责完成循环变量初始化。 ②负责判断是否满足循环条件，不满足则跳出循环。 ③具体执行的语句 ④循环后，循环变量的变化情况 输出10次HelloWorld 1234567public static void main(String[] args) &#123; int x=1; do &#123; System.out.println("HelloWorld"); x++; &#125;while(x&lt;=10);&#125; do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。这样的 循环具有一定的风险性，因此初学者不建议使用do…while循环。 循环语句的区别 for 和 while 的小区别： 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。跳出语句break 使用场景：终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的123456789public static void main(String[] args) &#123; for (int i = 1; i&lt;=10; i++) &#123; //需求:打印完两次HelloWorld之后结束循环 if(i == 3)&#123; break; &#125; System.out.println("HelloWorld"+i); &#125;&#125; continue 使用场景：结束本次循环，继续下一次的循环123456789public static void main(String[] args) &#123; for (int i = 1; i &lt;= 10; i++) &#123; //需求:不打印第三次HelloWorld if(i == 3)&#123; continue; &#125; System.out.println("HelloWorld"+i); &#125;&#125; 死循环 死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。在后期的开发中，会出现使用死循环的场景，例如：我们需要读取用户输入的输入，但是用户输入多少数据我们并 不清楚，也只能使用死循环，当用户不想输入数据了，就可以结束循环了，如何去结束一个死循环呢，就需要使用 到跳出语句了。 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总 共的循环次数=外循环次数*内循环次数 嵌套循环格式： 12345for(初始化表达式①; 循环条件②; 步进表达式⑦) &#123; for(初始化表达式③; 循环条件④; 步进表达式⑥) &#123; 执行语句⑤; &#125;&#125; 嵌套循环执行流程： 执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥ 外循环一次，内循环多次。 比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>流程控制</tag>
        <tag>选择语句</tag>
        <tag>循环语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程控制之判断语句]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[流程控制概述在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果 有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现 我们要完成的功能。 判断语句判断语句1–if if语句第一种格式： if 123if(关系表达式)｛ 语句体; ｝ 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体 如果是false就不执行语句体 1234567891011121314151617181920212223public static void main(String[] args)&#123; //顺序执行，根据编写的顺序，从上到下运行 System.out.println(1); System.out.println(2); System.out.println(3); &#125; if(关系表达式)｛ 语句体; ｝ public static void main(String[] args)&#123; System.out.println("开始"); // 定义两个变量 int a = 10; int b = 20; //变量使用if判断 if (a == b)&#123; System.out.println("a等于b"); &#125; int c = 10; if(a == c)&#123; System.out.println("a等于c"); &#125; System.out.println("结束"); ｝ &#125;&#125; 判断语句2–if…else if语句第二种格式： if…else 12345if(关系表达式) &#123; 语句体1; &#125;else &#123; 语句体2; &#125; 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 1234567891011public static void main(String[] args)&#123; // 判断给定的数据是奇数还是偶数 // 定义变量 int a = 1; if(a % 2 == 0) &#123; System.out.println("a是偶数"); &#125; else&#123; System.out.println("a是奇数"); &#125; System.out.println("结束");&#125; 判断语句3–if..else if…else if语句第三种格式： if…else if …else 1234567891011if (判断条件1) &#123; 执行语句1; &#125; else if (判断条件2) &#123; 执行语句2; &#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 执行流程 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句体2 如果是false就继续判断关系表达式…看其结果是true还是false … 如果没有任何关系表达式为true，就执行语句体n+1。 123456789101112131415161718public static void main(String[] args) &#123; // x和y的关系满足如下： // x&gt;=3 y = 2x + 1; //‐1&lt;=x&lt;3 y = 2x; // x&lt;=‐1 y = 2x – 1; // 根据给定的x的值，计算出y的值并输出。 // 定义变量 int x = 5; int y; if (x&gt;= 3) &#123; y = 2 * x + 1; &#125; else if (x &gt;= ‐1 &amp;&amp; x &lt; 3) &#123; y = 2 * x; &#125; else &#123; y = 2 * x ‐ 1; &#125; System.out.println("y的值是："+y);&#125; if语句和三元运算符的互换在某些简单的应用中，if语句是可以和三元运算符互换使用的. 12345678910111213public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //可以上述功能改写为三元运算符形式 c = a &gt; b ? a:b;&#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>流程控制</tag>
        <tag>判断语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的javac编译器]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%9C%89%E8%B6%A3%E7%9A%84javac%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。12345678910111213public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte，不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧的范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围 // int --&gt; char，没有超过范围 // 编译器将会自动补上一个隐含的(char) char zifu = /*(char)*/ 65; System.out.println(zifu); // A&#125; 在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算编译之后，得到的.class字节码文件当中相当于【直接就是】：short result = 13;右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化”。 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 1234567891011121314public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧的范围， short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 18 &#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。·方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 定义定义格式：1234修饰符 返回值类型 方法名 （参数列表）｛ 代码... return 返回值; ｝ 定义格式解释： 修饰符： 目前固定写法 public static 。 返回值类型： 目前固定写法 void ，其他返回值类型在后面的课程讲解。 方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。 参数列表： 目前无参数， 带有参数的方法在后面的课程讲解。 return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。举例123public static void methodName() &#123; System.out.println("这是一个方法"); &#125; 方法的调用方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在 主方法中，直接写要调用的方法名字就可以调用了。 12345678public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用public static void method() &#123; System.out.println("自己定义的方法，需要被main调用运行"); &#125; 注意事项方法定义注意事项：使用方法的时候，注意事项： 方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。 方法定义的前后顺序无所谓。 方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。 如果方法有返回值，那么必须写上“return 返回值;”，不能没有。 return后面的返回值数据，必须和方法的返回值类型，对应起来。 对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。 对于void方法当中最后一行的return可以省略不写。 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。方法重载方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。参数列表：个数不同，数据类型不同，顺序不同。重载方法调用：JVM通过方法的参数列表，调用不同的方法。*****只要方法名相同，参数列表不一致，就是方法重载*****]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[运算符：进行特定操作的符号。例如：+表达式：用运算符连起来的式子叫做表达式。例如：20 + 5。又例如：a + b 算数运算符 对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。 只有对于整数的除法来说，取模运算符才有余数的意义。 注意事项： 1. 一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。 123456789101112131415161718192021222324252627 public class Operator &#123; public static void main(String[] args) &#123; // 两个常量之间可以进行数学运算 System.out.println(20 + 30); // 两个变量之间也可以进行数学运算 int a = 20; int b = 30; System.out.println(a - b); // -10 // 变量和常量之间可以混合使用 System.out.println(a * 10); // 200 int x = 10; int y = 3; int result1 = x / y; System.out.println(result1); // 3 int result2 = x % y; System.out.println(result2); // 余数，模，1 // int + double --&gt; double + double --&gt; double double result3 = x + 2.5; System.out.println(result3); // 12.5 &#125;&#125; +号的用法四则运算当中的加号“+”有常见的三种用法： 对于数值来说，那就是加法。 对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode 对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。任何数据类型和字符串进行连接的时候，结果都会变成字符串12345678910111213141516171819202122public class Demo05Plus &#123; public static void main(String[] args) &#123; // 字符串类型的变量基本使用 // 数据类型 变量名称 = 数据值; String str1 = "Hello"; System.out.println(str1); // Hello System.out.println("Hello" + "World"); // HelloWorld String str2 = "Java"; // String + int --&gt; String System.out.println(str2 + 20); // Java20 // 优先级问题 // String + int + int // String + int // String System.out.println(str2 + 20 + 30); // Java2030 System.out.println(str2 + (20 + 30)); // Java50 &#125;&#125; ++和–自增运算符：++自减运算符：– 基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1使用格式：写在变量名称之前，或者写在变量名称之后。例如：++num，也可以num++使用方式： 1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。 2. 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。使用区别： 1. 在单独使用的时候，前++和后++没有任何区别。也就是：++num;和num++;是完全一样的。 2. 在混合的时候，有【重大区别】 A. 如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用。 【先加后用】 B. 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。 【先用后加】 注意事项： 只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Operator &#123; public static void main(String[] args) &#123; int num1 = 10; System.out.println(num1); // 10 ++num1; // 单独使用，前++ System.out.println(num1); // 11 num1++; // 单独使用，后++ System.out.println(num1); // 12 System.out.println("================="); // 与打印操作混合的时候 int num2 = 20; // 混合使用，先++，变量立刻马上变成21，然后打印结果21 System.out.println(++num2); // 21 System.out.println(num2); // 21 System.out.println("================="); int num3 = 30; // 混合使用，后++，首先使用变量本来的30，然后再让变量+1得到31 System.out.println(num3++); // 30 System.out.println(num3); // 31 System.out.println("================="); int num4 = 40; // 和赋值操作混合 int result1 = --num4; // 混合使用，前--，变量立刻马上-1变成39，然后将结果39交给result1变量 System.out.println(result1); // 39 System.out.println(num4); // 39 System.out.println("================="); int num5 = 50; // 混合使用，后--，首先把本来的数字50交给result2，然后我自己再-1变成49 int result2 = num5--; System.out.println(result2); // 50 System.out.println(num5); // 49 System.out.println("================="); int x = 10; int y = 20; // 11 + 20 = 31 int result3 = ++x + y--; System.out.println(result3); // 31 System.out.println(x); // 11 System.out.println(y); // 19 // 30++; // 错误写法！常量不可以使用++或者-- &#125;&#125; 赋值运算符赋值运算符分为： 基本赋值运算符：就是一个等号“=”，代表将右侧的数据交给左侧的变量。 int a = 30; 复合赋值运算符： += a += 3 相当于 a = a + 3 -= b -= 4 相当于 b = b - 4 *= c *= 5 相当于 c = c * 5 /= d /= 6 相当于 d = d / 6 %= e %= 7 相当于 e = e % 7注意事项： 1. 只有变量才能使用赋值运算符，常量不能进行赋值。 2. 复合赋值运算符其中隐含了一个强制类型转换。 123456789101112131415161718192021222324252627282930public class Operator &#123; public static void main(String[] args) &#123; int a = 10; // 按照公式进行翻译：a = a + 5 // a = 10 + 5; // a = 15; // a本来是10，现在重新赋值得到15 a += 5; System.out.println(a); // 15 int x = 10; // x = x % 3; // x = 10 % 3; // x = 1; // x本来是10，现在重新赋值得到1 x %= 3; System.out.println(x); // 1 // 50 = 30; // 常量不能进行赋值，不能写在赋值运算符的左边。错误写法！ byte num = 30; // num = num + 5; // num = byte + int // num = int + int // num = int // num = (byte) int num += 5; System.out.println(num); // 35 &#125;&#125; 比较运算符比较运算符：注意事项： 比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false 如果进行多次判断，不能连着写。数学当中的写法，例如：1 &lt; x &lt; 3程序当中【不允许】这种写法。12345678910111213141516171819public class Demo08Operator &#123; public static void main(String[] args) &#123; System.out.println(10 &gt; 5); // true int num1 = 10; int num2 = 12; System.out.println(num1 &lt; num2); // true System.out.println(num2 &gt;= 100); // false System.out.println(num2 &lt;= 100); // true System.out.println(num2 &lt;= 12); // true System.out.println("==============="); System.out.println(10 == 10); // true System.out.println(20 != 25); // true System.out.println(20 != 20); // false int x = 2; // System.out.println(1 &lt; x &lt; 3); // 错误写法！编译报错！不能连着写。 &#125;&#125; 逻辑运算符与（并且） &amp;&amp; 全都是true，才是true；否则就是false或（或者） || 至少一个是true，就是true；全都是false，才是false非（取反） ! 本来是true，变成false；本来是false，变成true 与“&amp;&amp;”，或“||”，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。注意事项： 逻辑运算符只能用于boolean值。 与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可。 与、或两种运算符，如果有多个条件，可以连续写。两个条件：条件A &amp;&amp; 条件B多个条件：条件A &amp;&amp; 条件B &amp;&amp; 条件CTIPS：对于1 &lt; x &lt; 3的情况，应该拆成两个部分，然后使用与运算符连接起来：int x = 2;1 &lt; x &amp;&amp; x &lt; 312345678910111213141516171819202122232425262728public class Logic &#123; public static void main(String[] args) &#123; System.out.println(true &amp;&amp; false); // false // true &amp;&amp; true --&gt; true System.out.println(3 &lt; 4 &amp;&amp; 10 &gt; 5); // true System.out.println("============"); System.out.println(true || false); // true System.out.println(true || true); // true System.out.println(false || false); // false System.out.println("============"); System.out.println(true); // true System.out.println(!true); // false System.out.println("============"); int a = 10; // false &amp;&amp; ... System.out.println(3 &gt; 4 &amp;&amp; ++a &lt; 100); // false System.out.println(a); // 10 System.out.println("============"); int b = 20; // true || ... System.out.println(3 &lt; 4 || ++b &lt; 100); // true System.out.println(b); // 20 &#125;&#125; 三目运算符三元运算符格式： 1数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式：布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125;]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据类型转换Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。当数据类型不一样时，将会发生数据类型转换。 自动类型转换（隐式） 1. 特点：代码不需要进行特殊处理，自动完成。 2. 规则：数据范围从小到大。 强制类型转换（显式） 12345678910111213141516171819202122232425public class DataType &#123; public static void main(String[] args) &#123; System.out.println(1024); // 这就是一个整数，默认就是int类型 System.out.println(3.14); // 这就是一个浮点数，默认就是double类型 // 左边是long类型，右边是默认的int类型，左右不一样 // 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行存储 // int --&gt; long，符合了数据范围从小到大的要求 // 这一行代码发生了自动类型转换。 long num1 = 100; System.out.println(num1); // 100 // 左边是double类型，右边是float类型，左右不一样 // float --&gt; double，符合从小到大的规则 // 也发生了自动类型转换 double num2 = 2.5F; System.out.println(num2); // 2.5 // 左边是float类型，右边是long类型，左右不一样 // long --&gt; float，范围是float更大一些，符合从小到大的规则 // 也发生了自动类型转换 float num3 = 30L; System.out.println(num3); // 30.0 &#125;&#125; 自动转换(隐式转换)一个 int 类型变量和一个 byte 类型变量进行加法运算， 结果会是什么数据类型？ 12345678public static void main(String[] args) &#123; int i = 1; byte b = 2; // byte x = b + i; // 报错 //int类型和byte类型运算，结果是int类型 int j = b + i; System.out.println(j);&#125; 运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。·自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。 转换原理图解byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类 型。同样道理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。 1234567public static void main(String[] args) &#123; int i = 1; double d = 2.5; //int类型和double类型运算，结果是double类型 //int类型会提升为double类型 double e = d+i; System.out.println(e);&#125; 转换规则范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。byte、short、char —&gt;int —&gt;long–&gt;float—&gt;double 强制转换(显示转换)强制类型转换 1. 特点：代码需要进行特殊的格式处理，不能自动完成。 2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据; 注意事项： 1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”. 3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。 4. boolean类型不能发生数据类型转换 1234567891011121314151617181920212223242526272829303132333435public class DataType &#123; public static void main(String[] args) &#123; // 左边是int类型，右边是long类型，不一样 // long --&gt; int，不是从小到大 // 不能发生自动类型转换！ // 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据; int num = (int) 100L; System.out.println(num); // long强制转换成为int类型 int num2 = (int) 6000000000L; System.out.println(num2); // 1705032704 // double --&gt; int，强制类型转换 int num3 = (int) 3.99; System.out.println(num3); // 3，这并不是四舍五入，所有的小数位都会被舍弃掉 char zifu1 = 'A'; // 这是一个字符型变量，里面是大写字母A System.out.println(zifu1 + 1); // 66，也就是大写字母A被当做65进行处理 // 计算机的底层会用一个数字（二进制）来代表字符A，就是65 // 一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字 byte num4 = 40; // 注意！右侧的数值大小不能超过左侧的类型范围 byte num5 = 50; // byte + byte --&gt; int + int --&gt; int int result1 = num4 + num5; System.out.println(result1); // 90 short num6 = 60; // byte + short --&gt; int + int --&gt; int // int强制转换为short：注意必须保证逻辑上真实大小本来就没有超过short范围，否则会发生数据溢出 short result2 = (short) (num4 + num6); System.out.println(result2); // 100 &#125;&#125; 将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值。 1int i = 1.5;//错误 double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。可以理解为 double 是8 升的水壶， int 是4升的水壶，不能把大水壶中的水直接放进小水壶去。 想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。·强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。转换格式： 1数据类型 变量名 = （数据类型）被转数据值; 将 1.5 赋值到 int 类型，代码修改为： 1int i = (int)1.5;//错误 同样道理，当一个 short 类型与 1 相加，我们知道会类型提升，但是还想给结果赋值给short类型变量，就需要强制转换。 12345678910111213public static void main(String[] args) &#123; //short类型变量，内存中2个字节 short s = 1; /* 出现编译失败 s和1做运算的时候，1是int类型，s会被提升为int类型 s+1后的结果是int类型，将结果在赋值会short类型时发生错误 short内存2个字节，int类型4个字节 必须将int强制转成short才能完成赋值 */ s = s + 1；//编译失败 s = (short)(s+1);//编译成功&#125; 转换原理图解 ### 强烈注意 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 1234// 定义s为short范围内最大值short s = 32767;// 运算后，强制转换，砍掉2个字节后会出现不确定的结果s = (short)(s + 10); ASCII编码表在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。·编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。将所有的英文字母，数字，符号都和十进制进行了对应，因此产生了世界上第一张编码表ASCII（American Standard Code for Information Interchange 美国标准信息交换码）。数字和字符的对照关系表（编码表）：·ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。·Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。48 - ‘0’65 - ‘A’97 - ‘a’ 12345678910111213141516public static void main(String[] args) &#123; char zifu1 = '1'; System.out.println(zifu1 + 0); // 49 char zifu2 = 'A'; // 其实底层保存的是65数字 char zifu3 = 'c'; // 左侧是int类型，右边是char类型， // char --&gt; int，确实是从小到大 // 发生了自动类型转换 int num = zifu3; System.out.println(num); // 99 char zifu4 = '中'; // 正确写法 System.out.println(zifu4 + 0); // 20013 &#125; 12345public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 小贴士：在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。char类型提升 为了int类型。char类型内存2个字节，int类型内存4个字节。]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量与变量和数据类型]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[常量概述常量：是指在Java程序中固定不变的数据 分类 练习需求：输出各种类型的常量。 1234567891011121314 public class ConstantDemo &#123; public static void main(String[] args)&#123; //输出整数常量 System.out.println(123); //输出小数常量 System.out.println(0.125); //输出字符常量 System.out.println('A'); //输出布尔常量 System.out.println(true); //输出字符串常量 System.out.println("你好Java"); &#125;&#125; 变量和数据类型变量的概述变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。 数学中，可以使用字母代替数字运算,例如 x=1+5 或者 6=x+5。程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。比如x保存5，x也可 以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。 数据类型数据类型分类-1 Java的数据类型分为两大类： 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。-2 引用数据类型：包括 类 、 数组 、 接口 。 基本数据类型四类八种基本数据类型： Java中的默认类型：整数类型是 int 、浮点类型是 double 。 变量的定义变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。格式 1数据类型 变量名 = 数据值; 练习定义所有基本数据类型的变量，代码如下： 12345678910111213141516171819202122232425262728public class Variable &#123; public static void main(String[] args)&#123; //定义字节型变量 byte b = 100; System.out.println(b); //定义短整型变量 short s = 1000; System.out.println(s); //定义整型变量 int i = 123456; System.out.println(i); //定义长整型变量 long l = 12345678900L; System.out.println(l); //定义单精度浮点型变量 float f = 5.5F; System.out.println(f); //定义双精度浮点型变量 double d = 8.5; System.out.println(d); //定义布尔型变量 boolean bool = false; System.out.println(bool); //定义字符型变量 char c = 'A'; System.out.println(c); &#125; &#125; long类型：建议数据后加L表示。ﬂoat类型：建议数据后加F表示。 注意事项变量名称：在同一个大括号范围内，变量的名字不可以相同。变量赋值：定义的变量，不赋值不能使用。]]></content>
      <categories>
        <category>java基础</category>
        <category>基本语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>常量</tag>
        <tag>变量</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld入门程序]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%85%A5%E9%97%A8%E7%AF%87%E5%87%86%E5%A4%87%2FHelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[java程序开发步骤Java程序开发三步骤：编写、编译、运行。 编写Java源程序 在 d:\day01 目录下新建文本文件，完整的文件名修改为 HelloWorld.java ，其中文件名为 HelloWorld ，后 缀名必须为 .java 。 用记事本打开 使用notepad++记事本软件。 在文件中键入文本并保存，代码如下：12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125; &#125; 文件名必须是 HelloWorld ，保证文件名和类的名字是一致的，注意大小写。每个字母和符号必须与示例代码一模一样。第一个 HelloWord 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我 们必须将编写好的 Java源文件 编译成JVM可以看懂的 字节码文件 。 编译Java源文件在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令： 1javac Java源文件名.后缀名 举例： 1javac HelloWorld.java 编译成功后，命令行没有任何提示。打开 HelloWord.java根目录，发现产生了一个新的文件 HelloWorld.class ，该文件 就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令： 1java 类名字 举例： 1java HelloWorld java HelloWord 不要写 不要写 不要写 .classJava源文件的编译工具 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目 录下使用。 入门程序说明编译和运行是两回事编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们 所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。运行：是指将 class文件 交给JVM去运行，此时JVM就会去执行我们编写的程序了。 关于main方法main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多 少程序，JVM在运行的时候，都会从main方法这里开始执行。 添加注释comment注释：就是对代码的解释和说明。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须 要的，它不影响程序的编译和运行。 Java中有单行注释和多行注释单行注释以 //开头 换行结束多行注释以 /开头 以/结束 关键字keywords关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母，notepad++中颜色特殊。关键字比较多，不能死记硬背，学到哪里记到哪里即可。 标识符标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。HelloWorld案例中，出现的标识符有类名字 HelloWorld 。命名规则： 硬性要求 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字。 命名规范： 软性建议类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。]]></content>
      <categories>
        <category>java基础</category>
        <category>入门篇准备</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式内容概述]]></title>
    <url>%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[设计模式的重要性1) 软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的2) 大厦 VS 简易房 （大工程和小工程）3) 拿实际工作经历来说, 当一个项目开发完后，如果客户提出增新功能，怎么办?。（可扩展性，使用设计模式具有很好的扩展性）4) 如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (维护性[可读性、 规范性])5) 目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中使用过什么 设计模式，怎样使用的，解决了什么问题。6) 设计模式在软件中哪里？面向对象(oo)=&gt;功能模块[设计模式+算法(数据结构)]=&gt;框 架[使用到多种设计模式]=&gt;架构 [服务器集群]7) 如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的. 设计模式的目的编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重 用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好1) 代码重用性 (即：相同功能的代码，不用多次编写)2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)5) 使程序呈现高内聚，低耦合的特性 设计模式七大原则设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模 式的基础(即：设计模式为什么这样设计的依据)设计模式常用的七大原则有:1) 单一职责原则2) 接口隔离原则3) 依赖倒转(倒置)原则4) 里氏替换原则5) 开闭原则6) 迪米特法则7) 合成复用原则]]></content>
      <categories>
        <category>java设计模式</category>
        <category>设计模式的内容概述</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2Fjava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列介绍1）队列是一个有序列表，可以用数组或是链表来实现。2）遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出3）示意图：(使用数组模拟队列示意图)数组模拟队列队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析1）将尾指针往后移：rear+1 , 当front == rear 【空】2）若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package queue;import java.util.Scanner;public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //测试一把 //创建一个队列 ArrayQueue queue = new ArrayQueue(3); char key = ' '; //接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while (loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;class ArrayQueue &#123; private int maxSize; private int front; private int rear; private int[] array; public ArrayQueue(int maxSize) &#123; this.maxSize = maxSize;//队列的最大长度 array = new int[maxSize];//数组的长度等于队列最大长度 front = -1;//对头指针 rear = -1;//队尾指针 &#125; public boolean isFull() &#123; return rear == maxSize - 1; &#125; public boolean isEmpty() &#123; return rear == front; &#125; public void addQueue(int value) &#123; if (isFull()) &#123; System.out.println("队列满了，你就别加了"); &#125; else &#123; array[++rear] = value; &#125; &#125; public int getQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空，你上哪取数据啊"); &#125; else &#123; return array[++front]; &#125; &#125; public void showQueue() &#123; if (isEmpty()) &#123; System.out.println("队列为空"); &#125; else &#123; for (int i = front +1; i &lt;= rear; i++) &#123; System.out.printf("%d\t", array[i]); &#125; &#125; &#125; public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空，你上哪取数据啊"); &#125; else &#123; return array[front + 1]; &#125; &#125;&#125;&#125; 问题分析并优化 目前数组使用一次就不能用，没有达到服用的效果 将这个数组使用算法，改进成一个环形的队列 取模：%]]></content>
      <categories>
        <category>java数据结构和算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组]]></title>
    <url>%2Fjava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[稀疏数组先看一个实际的需求编写的五子棋程序中，有存盘退出和续上盘的功能。分析问题:因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据.-&gt;稀疏数组。 稀疏数组介绍基本介绍当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是:1）记录数组一共有几行几列，有多少个不同的值2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 稀疏数组举例说明 应用实例1）使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)2）把稀疏数组存盘，并且可以从新恢复原来的二维数组数3）整体思路分析 二维数组和稀疏数组相互转化二维数组 转 稀疏数组的思路 遍历 原始的二维数组，得到有效数据的个数 sum 根据sum 就可以创建 稀疏数组 sparseArr int[sum + 1] [3] 将二维数组的有效数据数据存入到 稀疏数组 稀疏数组转原始的二维数组的思路 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可. 代码实现1234567891011121314151617181920212223242526272829//将二位数组转化成稀疏数组 public static int[][] parseSparseArray(int[][] array)&#123; //sum用来记录有几个非0值 int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length; j++) &#123; if (array[i][j]!=0)&#123; sum ++; &#125; &#125; &#125; int[][] sparseArray = new int[sum+1][3]; sparseArray[0][0] = array.length; sparseArray[0][1] = array[0].length; sparseArray[0][2] = sum; //count用来记录是稀疏数组的哪一行 int count = 0; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length; j++) &#123; if (array[i][j]!=0)&#123; count++; sparseArray[count][0] = i; sparseArray[count][1] = j; sparseArray[count][2] = array[i][j]; &#125; &#125; &#125; return sparseArray; &#125; 123456789//将稀疏数组转化为二维数组 public static int[][] toArray(int[][] sparseArray)&#123; int[][] array = new int[sparseArray[0][0]][sparseArray[0][1]]; //更改二位数组中应该非0的值 for (int i = 1; i &lt; sparseArray.length; i++) &#123; array[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2]; &#125; return array; &#125;]]></content>
      <categories>
        <category>java数据结构和算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法的关系]]></title>
    <url>%2Fjava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[数据结构和算法的关系1）数据data结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。2）要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.3）程序 = 数据结构 + 算法4）数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。 线性结构和非线性结构数据结构包括：线性结构和非线性结构。 线性结构1）线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。2）线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。3）链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。4）线性结构常见的有：数组、队列、链表和栈。 非线性结构非线性结构包括：二维数组，多维数组，广义表，树结构，图结构]]></content>
      <categories>
        <category>java数据结构和算法</category>
        <category>数据结构与算法的关系</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机基础知识]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[二进制 计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机全部采用二进制数表示，它只包含0、1两个数，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特，位）。十进制转换二进制 除以2 取余 反向读二进制转换十进制 从右往左数字乘以2^0 + 数字乘以2^1 + … + 数字乘以2^n 字节字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都以字节的形式存储，右键文件属性，我们可以直接查看文件的字节大小。8个bit（二进制位）0000-0000表示为1个字节，写成1byte或者1B。·8bit = 1Byte·1024B = 1KB·1024MB = 1GB·1024GB = 1TB 常见DOS命令MS-DOS(Microsoft Disk Operating System)微软磁盘操作系统cmd(命令提示符)启动：Win+R 》》输入cmd回车x: 切换到盘符xcd + 路径跳转到目录（tab键可以自动补全路径）cd ..返回上一级目录cd \ 返回根目录dir 显示文件夹中的所有文件信息cls 清屏exit 退出cmd]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>计算机常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java环境搭建]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%85%A5%E9%97%A8%E7%AF%87%E5%87%86%E5%A4%87%2Fjava%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[java虚拟机—–JVM·JVM(Java Vrtual Mechine)：java虚拟机，简称JVM.是运行所有java程序的假想计算机，是java程序的运行环境，是java最具有吸引力 特性之一。我们编写的代码，都运行在JVM之上。·跨平台：任何软件的运行，都必须要运行在操作系统上，而我们用java编写的软件可以运行在任何的操作系统上，这个特性称为java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 JRE和JDK·JRE(Java Runtime Environment)：是java程序的运行时环境，包含JVM和运行时所需要的核心类库。·JDK(Java Development Kit)：是java程序开发工具包，包含JRE和开发人员使用的工具。我们想要运行已有的一个java程序，那么只需安装JRE即可。我们想要开发一个全新的java程序，那么必须安装JDK。 下载安装JDK（以JDK1.8为例子，因为该版本使用量较大） Oracle首页 选择jdk1.8版本下载 点击Download 先勾选接受 后选择符合你系统的版本 最后登录Oracle账号就会自动下载了，没有账号的可以百度搜索一个。 双击下载好的jdk就可以安装 jdk中包含JRE不需要额外在安装一个独立的JRE 安装路径最好不要有中文和空格，一定要记住你的安装路径！！！！！！！！！！！后面会用到 安装完毕后 右键此电脑==》属性 按图中标号依次点击 按图中标号依次点击，最后选择你的jdk根目录 按图中标号依次点击和输入 打开命令提示符，输入红框中的内容，与图一致则完成配置]]></content>
      <categories>
        <category>java基础</category>
        <category>入门篇准备</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
